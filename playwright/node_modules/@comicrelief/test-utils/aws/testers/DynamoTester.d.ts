import aws from 'aws-sdk';
import { Tester } from '../../Tester';
/**
 * Identifies an S3 reference
 */
interface DynamoReference<T> {
    TableName: string;
    Key: T;
}
export declare type KeyGenerator = (record: aws.DynamoDB.DocumentClient.AttributeMap) => Record<string, unknown>;
/**
 * Maximum operations that can be performed
 * as part of a batchWrite call.
 * See: https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_BatchWriteItem.html
 */
export declare const BATCH_WRITES_MAXIMUM_OPERATIONS = 25;
/**
 * Maximum retries for a failed batch
 */
export declare const BATCH_WRITES_MAXIMUM_RETRIES = 10;
/**
 * Unit of time (ms), used in waiting between retries
 */
export declare const BACKOFF_WAIT_UNIT = 1000;
/**
 * Manages cleanup of S3 files
 * during feature tests.
 *
 * @class
 */
export declare class DynamoTester<T> extends Tester<DynamoReference<T>> {
    client: aws.DynamoDB.DocumentClient;
    maxAttempts: number;
    waitUnit: number;
    /**
     * Call parent constructor,
     * Setup client and needed operation props.
     *
     * @param maxAttempts = BATCH_WRITES_MAXIMUM_RETRIES Max number to retry failed attempts
     * @param waitUnit    = 1000                         Unit of time in ms, to be multiplied by a digit
     */
    constructor(maxAttempts?: number, waitUnit?: number);
    /**
     * Puts a row in the specified DynamoDB Table
     *
     * @param row
     * @param item
     */
    put(row: DynamoReference<T>, item: Record<string, unknown>): Promise<aws.DynamoDB.DocumentClient.PutItemOutput>;
    /**
     * Gets the specified row
     *
     * @param row
     */
    get(row: DynamoReference<T>): Promise<aws.DynamoDB.DocumentClient.GetItemOutput>;
    /**
     * Returns an iterator
     * that will iterate through
     * all the entries on a DynamoDB table
     *
     * @param TableName
     * @param Limit
     * @param ScanInput - Optional parameters to pass to the scan call
     */
    iterate(TableName: string, Limit?: number, ScanInput?: Partial<aws.DynamoDB.DocumentClient.ScanInput>): AsyncGenerator<aws.DynamoDB.DocumentClient.ItemList>;
    /**
     * Deletes the specified row
     *
     * @param row
     */
    delete(row: DynamoReference<T>): Promise<aws.DynamoDB.DocumentClient.DeleteItemOutput>;
    /**
     * @inheritdoc
     * @param row
     */
    removeReference(row: DynamoReference<T>): Promise<void>;
    /**
     * Execute a batch write on a DynamoDB Table,
     * with retrials for unprocessed items due to throttling or whatever reason .
     *
     * @param batch
     * @param nextWait - Optional wait (ms) used for exponential backoff
     * @param attempt - Optional attempt counter to avoid infinite retries
     * @returns Promise
     */
    batchWrite(batch: aws.DynamoDB.DocumentClient.BatchWriteItemInput, nextWait?: number, attempt?: number): Promise<aws.DynamoDB.DocumentClient.BatchWriteItemOutput>;
    /**
     * Truncates a DynamoDB Table
     *
     * @param TableName
     * @param keyGenerator - Optional row key generator
     * @param ScanInput - Optional parameters to pass to the scan call
     * @returns Promise
     */
    truncate(TableName: string, keyGenerator?: KeyGenerator | null, ScanInput?: Partial<aws.DynamoDB.DocumentClient.ScanInput>): Promise<aws.DynamoDB.DocumentClient.BatchWriteItemOutput[]>;
}
export {};
//# sourceMappingURL=DynamoTester.d.ts.map