import { Model, RequiredKeys } from './validation';
/**
 * Defines a subtype with some of the keys
 * of the mapped type. Doesn't check their type.
 */
export declare type PartialKeys<T> = {
    [K in keyof T]?: unknown;
};
export declare type Mocks<ModelProps> = {
    [key: string]: PartialKeys<ModelProps>;
};
export declare type ValidMocks<ModelProps> = {
    [key: string]: ModelProps;
};
/**
 * Merges two objects, where the second
 * is a partial of the first.
 *
 * @param instance
 * @param overrides
 */
export declare const override: <I, O extends PartialKeys<I>>(instance: I, overrides: O) => I & O;
/**
 * Makes a collection of override mocks.
 *
 * One for every key/value pair in `overrides`.
 *
 * @param instance
 * @param overrides
 * @param _prefix
 */
export declare const makeOverrideMocks: <ModelProps>(instance: ModelProps, overrides: PartialKeys<ModelProps>, _prefix?: string) => Mocks<ModelProps>;
/**
 * Makes a collection of omit mocks.
 *
 * One for every key in `keys`.
 *
 * @param instance
 * @param keys
 * @param _prefix
 */
export declare const makeOmitMocks: <ModelProps>(instance: ModelProps, keys: (keyof ModelProps)[], _prefix?: string) => Mocks<ModelProps>;
/**
 * Makes a collection of override mocks based on `instance`.
 *
 * For every property in `keys`, a mock will be generated where that
 *  property is `null`.
 *
 * @param instance
 * @param keys
 */
export declare const makeNullOverrideMocks: <ModelProps>(instance: ModelProps, keys: (keyof ModelProps)[]) => Mocks<ModelProps>;
/**
 * Makes a selection of standard valid and invalid mocks.
 *
 * - `DEFAULT` mocks based on the `valid` and `invalid` objects.
 * - `INVALID_` mocks for every property on the `invalid` object.
 * - `MISSING_` and `NULL_` mocks for every property on the `valid` object.
 *     (`optional` and `nullable` params determine which of these should
 *     be valid and which ones should be invalid.)
 *
 * @param valid
 * @param invalid
 * @param nullable - array of keys for which the `NULL_` mock is valid.
 * @param optional - array of keys for which the `MISSING_` mock is valid.
 */
export declare const makeDefaultMocks: <ModelProps>(valid: ModelProps, invalid: RequiredKeys<ModelProps>, nullable?: (keyof ModelProps)[], optional?: (keyof ModelProps)[]) => {
    valid: ValidMocks<ModelProps>;
    invalid: Mocks<ModelProps>;
};
/**
 * Maps the keys in Mocks
 * to new override keys
 *
 * NB: Could do with also typing
 * the override of Property,
 * but I am not sure TypeScript 4.1 supports
 * the re-use of K original value
 *
 * These are types for mocks, the important bit
 * is that they appear in the mocks object
 */
export declare type OverrideFromMocksKeys<Origin, Property extends string, Mocks> = {
    [K in keyof Mocks as `OVERRIDE_${Uppercase<Property>}_WITH_${string & K}`]: Origin;
};
/**
 * Generates mocks overriding a property
 * from the given object of mocks.
 * Helpful for models that define a key
 * that is actually another model
 * and of which we have mocks.
 *
 * @param origin
 * @param property
 * @param mocks
 */
export declare const overrideFromMocks: <Origin extends Record<string, unknown>, Property extends keyof Origin & string, Mocks_1 extends Record<string, unknown>>(origin: Origin, property: Property, mocks: Mocks_1, commonOverrides?: Record<string, unknown>) => OverrideFromMocksKeys<Origin, Property, Mocks_1>;
/**
 * Clones an object, omitting a list of keys
 *
 * @param instance
 * @param keys
 */
export declare const omit: <I, O extends keyof I>(instance: I, keys: O[]) => Omit<I, O>;
/**
 * Filters an object, returning
 * only the specified keys
 *
 * @param instance
 * @param keys
 */
export declare const pick: <I, O extends keyof I>(instance: I, keys: O[]) => Pick<I, O>;
/**
 * Gets a random element from an array
 *
 * @param items
 */
export declare const getRandomElement: <T>(items: Record<string | number, T> | T[]) => T;
export declare const ALPHABET_UPPERCASE = "QWERTYUIOPASDFGHJKLZXCVBNM";
export declare const ALPHABET_LOWERCASE = "qwertyuiopasdfghjklzxcvbnm";
export declare const ALPHABET_NUMBERS = "1234567890";
export declare const ALPHABET: {
    UPPERCASE: string;
    LOWERCASE: string;
    NUMBERS: string;
};
/**
 * Returns a random character
 * given the provided options
 *
 * @param param0
 * @param param0.uppercase
 * @param param0.lowercase
 * @param param0.numbers
 */
export declare const getCharacter: ({ uppercase, lowercase, numbers }?: {
    uppercase?: boolean | undefined;
    lowercase?: boolean | undefined;
    numbers?: boolean | undefined;
}) => string;
/**
 * Returns a number between `min` and `max`
 *
 * @param min
 * @param max
 */
export declare const getNumber: (min?: number, max?: number, { decimals }?: {
    decimals?: number | undefined;
}) => number;
/**
 * Returns a integer between `min` and `max` (inclusive)
 *
 * @param min
 * @param max
 */
export declare const getInteger: (min?: number, max?: number) => number;
/**
 * Returns a random boolean value
 */
export declare const getBoolean: () => boolean;
/**
 * Returns a random string
 * given the provided options
 *
 * @param length
 * @param param1
 * @param param1.uppercase
 * @param param1.lowercase
 * @param param1.numbers
 */
export declare const getString: (length?: number, { uppercase, lowercase, numbers }?: {
    uppercase?: boolean | undefined;
    lowercase?: boolean | undefined;
    numbers?: boolean | undefined;
}) => string;
/**
 * Re-exports uuid.v4
 * for convenience
 */
export declare const getUuid: () => string;
/**
 * Generates a random URL
 *
 * @param param0 Options
 * @param param0.baseUrl Defaults to 'www.comicrelief.com'
 * @param param0.path Defaults to '/'
 * @param param0.https Protocol to use, defaults to 'https'
 * @param param0.randomSuffix Whether a random suffix should be postpended to generate unique URLs
 */
export declare const getUrl: ({ baseUrl, path, proto, randomSuffix }?: {
    baseUrl?: string | undefined;
    path?: string | undefined;
    proto?: string | undefined;
    randomSuffix?: boolean | undefined;
}) => string;
/**
 * Domain for test emails.
 * Managed by `serverless-tests-platform`
 */
export declare const TEST_EMAIL_DOMAIN = "test.sls.comicrelief.com";
/**
 * Prefix for UK mobile numbers
 */
export declare const TEST_MOBILE_PREFIX = "+447";
/**
 * Generates an email address
 */
export declare const getEmail: () => string;
/**
 * Generates a mobile number
 */
export declare const getMobile: () => string;
/**
 * Returns a random unix timestamp
 * given the provided options
 *
 * @param base - Base timestamp from which we add/subtract the variance
 * @param magnitude - Variance coefficient (positive number for future dates, negative number for past dates)
 */
export declare const getUnixTimestamp: (base?: number | null, magnitude?: number) => number;
/**
 * Returns a random ISO timestamp
 * given the provided options
 *
 * @param base - Base timestamp from which we add/subtract the variance
 * @param magnitude - Variance coefficient (positive number for future dates, negative number for past dates)
 */
export declare const getTimestamp: (base?: number | null, magnitude?: number) => string;
/**
 * Returns a random date
 * given the provided options
 *
 * @param base - Base timestamp from which we add/subtract the variance
 * @param magnitude - Variance coefficient (positive number for future dates, negative number for past dates)
 */
export declare const getDate: (base?: number | null, magnitude?: number) => Date;
/**
 * Returns an array of the requested length, with each element generated by
 * `itemGenerator`.
 *
 * @param length - Number of items.
 * @param itemGenerator - Function to generate an item in the array.
 */
export declare const generateList: <T>(length: number, itemGenerator: () => T) => T[];
/**
 * Compares two objects or arrays recursively,
 * and returns a new object/array with just the values
 * that are identical between the two.
 *
 * Typing is not strict because the resulting object type
 * is something in the shape of a RecursivePartial<T>
 * which we don't care enough to define and maintain.
 * Since this util is to be used just to feed objects to
 * jest snapshots and nothing else, we can keep the loose type.
 *
 * A function can be provided that will be called with any mismatching
 * values. Its return value will be used for the current property.
 *
 * @param obj1
 * @param obj2
 * @param handleMismatches
 */
export declare const getSnapshottableValues: <T>(obj1: T, obj2: T, handleMismatches?: ((a: unknown, b: unknown) => unknown) | undefined) => Record<string, unknown> | unknown[];
/**
 * Specialised version of `getSnapshottableValues` which takes a model and a
 * set of valid values, & runs validation twice to generate the two objects to
 * compare.
 *
 * Also provides a `handleMismatches` callback which will throw an error unless
 * there's special handling for a given mismatch.
 *
 * @param model
 * @param values
 * @param options
 */
export declare const getSnapshottableForModel: <T>(model: Model<T>, values: T, options?: {}) => Promise<Record<string, unknown> | unknown[]>;
/**
 * Type helper for records returned from Athena.
 *
 * The `athena-client` package that we use to query Athena does not return the
 * same field types as in the Parquet records. Instead all fields are returned
 * as strings. `null` values are returned as empty strings.
 *
 * `T` should be the Parquet record props, and the resulting type has all the
 * same keys with `string` values.
 */
export declare type AthenaResult<T> = {
    [K in keyof T]: string;
};
//# sourceMappingURL=utils.d.ts.map