"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.ErpCurrencies = exports.ErpCurrencyField = exports.NumericBoolField = exports.NumericBoolValues = exports.NumericBool = exports.CURRENT_CAMPAIGN = exports.Currencies = exports.SupporterUUID = exports.SupporterInfo = exports.EmailOrMobileTest = exports.StringBoolean = exports.JsonString = exports.NonEmptyString = exports.TimestampOrNow = exports.Timestamp = exports.UnixTimestamp = exports.AddressLine = exports.Mobile = exports.Email = exports.LastName = exports.FirstName = exports.UUID = exports.defineModel = exports.MetadataSymbol = exports.Namespaces = void 0;
var uuid_1 = require("uuid");
var yup = __importStar(require("yup"));
var enums_1 = require("./enums");
var errors_1 = require("./errors");
var StrictString_1 = require("./fields/StrictString");
var datetime_1 = require("./validators/datetime");
var phoneNumber_1 = require("./validators/phoneNumber");
var Namespaces;
(function (Namespaces) {
    Namespaces["CONTACT_STORE"] = "contact-store";
    Namespaces["ERP_SERVICE"] = "erp-service";
    Namespaces["MAILER_SERVICE"] = "mailer";
    Namespaces["PAYMENTS"] = "payments";
    Namespaces["PRIZE_PLATFORM_SERVICE"] = "prize-platform";
    Namespaces["SUPPORTER_EVENTS_SERVICE"] = "supporter-events";
    Namespaces["TESTS_PLATFORM_SERVICE"] = "tests-platform";
    Namespaces["USER_SERVICE"] = "user-service";
    Namespaces["FUNDRAISING"] = "fundraising";
    Namespaces["MARKETING_PREFERENCES"] = "marketing-preferences";
})(Namespaces = exports.Namespaces || (exports.Namespaces = {}));
exports.MetadataSymbol = Symbol('Metadata');
/**
 * Defines a model, returning a Model object
 * based on the provided Schema
 *
 * @param namespace
 * @param model
 * @param schema
 */
var defineModel = function (namespace, model, schema) { return ({
    namespace: namespace,
    model: model,
    schema: schema,
    validate: function (obj, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var validated, error_1;
            var _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _b.trys.push([0, 2, , 3]);
                        return [4 /*yield*/, schema().defined().validate(obj, __assign({ abortEarly: false }, options))];
                    case 1:
                        validated = _b.sent();
                        return [2 /*return*/, __assign(__assign({}, validated), (_a = {}, _a[exports.MetadataSymbol] = { namespace: namespace, model: model }, _a))];
                    case 2:
                        error_1 = _b.sent();
                        throw new errors_1.ValidationError(error_1, namespace + ":" + model);
                    case 3: return [2 /*return*/];
                }
            });
        });
    },
    isValid: function (obj, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var validated;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.validate(obj, options)];
                    case 1:
                        validated = _a.sent();
                        return [2 /*return*/, Boolean(validated)];
                }
            });
        });
    },
    validateSync: function (obj, options) {
        var _a;
        if (options === void 0) { options = {}; }
        try {
            var validated = schema().defined().validateSync(obj, __assign({ abortEarly: false }, options));
            return __assign(__assign({}, validated), (_a = {}, _a[exports.MetadataSymbol] = { namespace: namespace, model: model }, _a));
        }
        catch (error) {
            throw new errors_1.ValidationError(error, namespace + ":" + model);
        }
    },
    isInstance: function (obj) {
        if (typeof obj !== 'object') {
            return false;
        }
        if (!obj) {
            return false;
        }
        if (!(exports.MetadataSymbol in obj)) {
            return false;
        }
        var metadata = obj[exports.MetadataSymbol];
        if (!metadata) {
            return false;
        }
        return metadata.model === model && metadata.namespace === namespace;
    },
}); };
exports.defineModel = defineModel;
/**
 * UUID Field.
 *
 * Defined here so that `uuid`
 * doesn't need to be imported
 * on other files.
 */
exports.UUID = yup.string().uuid().default(uuid_1.v4);
/**
 * FirstName field.
 *
 * TODO: Implement FirstName validation
 */
exports.FirstName = yup.string();
/**
 * LastName field.
 *
 * TODO: Implement LastName validation
 */
exports.LastName = yup.string();
/**
 * Email field.
 *
 * TODO: Extend Email validation
 */
exports.Email = yup.string().email();
/**
 * Mobile field.
 *
 * TODO: Extend Mobile validation
 * (see `validateMobile`)
 */
exports.Mobile = yup.string()
    .transform(phoneNumber_1.normaliseUkPhoneNumber)
    // eslint-disable-next-line no-template-curly-in-string
    .test('validate-mobile', "${path} is not a valid mobile number: '${value}'", phoneNumber_1.validateMobile);
/**
 * A line of a postal address.
 *
 * This regex comes from Marketing Preferences service, modified to fix some
 * bugs. Gift Aid doesn't seem to have any back-end address validation.
 *
 * todo: check whether we want to use this validation for other services, or
 * not have any validation at all. Is there a risk that a valid address could
 * be populated by the postcode lookup but then rejected by the backend?
 */
exports.AddressLine = StrictString_1.TrimmedStrictString
    .matches(/^[a-zA-Z0-9.'\-_& ]+$/, 
// eslint-disable-next-line no-template-curly-in-string
"${path} must contain only alphanumeric characters and . ' - _ &");
/**
 * Unix Timestamp
 *
 * Represents a Unix Timestamp in seconds
 * and transforms it into a JavaScript Date
 */
exports.UnixTimestamp = yup.date().transform(function (timestamp) { return timestamp * 1000; });
/**
 * Timestamp
 *
 * Represents an ISO timestamp
 * and keeps it as a string.
 *
 * Useful for validating strings
 * that should be valid timestamps
 * without casting them to Date objects.
 */
// eslint-disable-next-line no-template-curly-in-string
exports.Timestamp = yup.string().test('validate-timestamp', "${path} is not a valid timestamp: '${value}'", datetime_1.validateTimestamp);
/**
 * Timestamp or Now
 *
 * Extends Timestamp by adding
 * a default value, the current date time
 * in ISO format.
 */
exports.TimestampOrNow = exports.Timestamp.default(function () { return new Date().toISOString(); });
/**
 * Non-empty string
 *
 * String values must be non-empty. Whitespace counts as empty.
 * `null` and `undefined` pass, as modifiers will handle these.
 */
exports.NonEmptyString = yup.string().test('non-empty', '${path} must not be an empty (or all-whitespace) string', // eslint-disable-line no-template-curly-in-string
function (value) {
    // these cases should be left for modifiers
    if (value === undefined || value === null) {
        return true;
    }
    // must be a string, and must be non-empty
    return typeof value === 'string' && value.trim().length !== 0;
});
/**
 * JsonString
 *
 * Enforces that a string contains
 * a valid JSON document that will
 * successfully JSON.parse'd without
 * losing information.
 */
exports.JsonString = yup.string()
    // eslint-disable-next-line no-template-curly-in-string
    .test('validate-json-string', "${path} is not a valid JSON string: '${value}'", function (value) {
    if (value === undefined || value === null) {
        // Let the modifiers handle this one.
        // yup defaults fields to `.optional()`
        // so it will be `.defined()` or `.required()`
        // to fail the validation
        return true;
    }
    if (typeof value !== 'string') {
        return false;
    }
    try {
        return JSON.stringify(JSON.parse(value)) === value;
    }
    catch (_a) {
        return false;
    }
});
/**
 * StringBoolean
 *
 * Behaves quite like `boolean` but with a few casts:
 * - 'false' -> false
 * - 'null' -> false
 * - 'NaN' -> false
 * - 'undefined' -> false
 * - '0' -> false
 *
 * In some circumstances we might get a stringified value,
 * for example the results of AWS Athena queries that are
 * ignoring the `.csv.metadata` file and using only the `.csv` file.
 */
exports.StringBoolean = yup.boolean().transform(function (value) {
    var falsyValues = ['false', 'null', 'undefined', '0'];
    if (falsyValues.includes(value)) {
        return false;
    }
    return Boolean(value);
});
/**
 * Performs an email or mobile test,
 * checking that at least one of them
 * has been defined.
 *
 * Doesn't perform email validation
 * nor mobile validation, leaving the task
 * to the individual fields in the schema.
 */
exports.EmailOrMobileTest = {
    name: 'email-or-mobile',
    // eslint-disable-next-line no-template-curly-in-string
    message: 'At least one of email or mobile must be defined',
    test: function (values) {
        if (!values) {
            return true;
        }
        var casted = values;
        return Boolean(casted.email || casted.mobile);
    },
};
/**
 * Validates a SupporterInfo field
 */
exports.SupporterInfo = yup.object({
    firstName: yup.string().required(),
    lastName: yup.string().required(),
    email: exports.Email.lowercase().defined(),
    mobile: exports.Mobile.lowercase().defined(),
    address1: yup.string().required(),
    postcode: yup.string().uppercase().required(),
    town: yup.string().required(),
    country: yup.string().required(),
})
    .test(exports.EmailOrMobileTest);
/**
 * Supporter UUID
 *
 * Represents a Supporter UUID
 * which is a required UUID by default
 * but can accept null/undefined if
 * `partial` is passed
 * to the context.
 */
exports.SupporterUUID = yup.string().uuid()
    .when('$partial', function (partial, schema) {
    if (partial) {
        return schema.default(function () { return null; }).defined();
    }
    var message = 'supporter_uuid must be a valid UUID unless `partial: true` is passed to the validation context';
    return schema.typeError(message).required(message);
});
/**
 * Currencies used at CR.
 * These are the only currencies
 * accepted by `serverless-payments`
 */
var Currencies;
(function (Currencies) {
    Currencies["AUD"] = "AUD";
    Currencies["EUR"] = "EUR";
    Currencies["GBP"] = "GBP";
    Currencies["USD"] = "USD";
})(Currencies = exports.Currencies || (exports.Currencies = {}));
/**
 * Represents the currently
 * active campaign
 *
 * On change, we will need to update
 * this library to the latest version
 * on the following repositories:
 * - `serverless-payments`
 * - `serverless-prize-platform`
 */
exports.CURRENT_CAMPAIGN = enums_1.Campaigns.YRW;
/**
 * Values for an ERP `Checkbox` field.
 */
var NumericBool;
(function (NumericBool) {
    NumericBool[NumericBool["NO"] = 0] = "NO";
    NumericBool[NumericBool["YES"] = 1] = "YES";
})(NumericBool = exports.NumericBool || (exports.NumericBool = {}));
/**
 * List of values in `NumericBool`.
 */
exports.NumericBoolValues = Object.values(NumericBool)
    .filter(function (it) { return typeof it === 'number'; });
/**
 * Schema for an ERP `Checkbox` field.
 */
exports.NumericBoolField = yup.number().oneOf(exports.NumericBoolValues);
/**
 * Schema for a `Currency` field.
 */
exports.ErpCurrencyField = yup.number();
/**
 * Values from ERP's `Currency` list.
 */
exports.ErpCurrencies = (_a = {},
    _a[Currencies.GBP] = Currencies.GBP,
    _a);
//# sourceMappingURL=validation.js.map