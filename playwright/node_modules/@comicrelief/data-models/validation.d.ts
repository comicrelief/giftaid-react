import * as yup from 'yup';
import { Campaigns } from './enums';
export declare enum Namespaces {
    CONTACT_STORE = "contact-store",
    ERP_SERVICE = "erp-service",
    MAILER_SERVICE = "mailer",
    PAYMENTS = "payments",
    PRIZE_PLATFORM_SERVICE = "prize-platform",
    SUPPORTER_EVENTS_SERVICE = "supporter-events",
    TESTS_PLATFORM_SERVICE = "tests-platform",
    USER_SERVICE = "user-service",
    FUNDRAISING = "fundraising",
    MARKETING_PREFERENCES = "marketing-preferences"
}
/**
 * Ensures all keys in are defined
 * in the implementing type.
 * Doesn't check their type, as this type
 * should be used as a mixin (see Schema<T> type)
 * where expecting all keys in a primary type
 * may be complex / not feasable.
 */
export declare type RequiredKeys<T> = {
    [K in keyof Required<T>]: unknown;
};
/**
 * Identifies a model schema, based on yup.
 * The type is a function that returns
 * a yup.ObjectSchema based on properties T.
 *
 * All properties of T, even those
 * marked as optional, are expected in the schema
 * as yup will need a rule for them. Presence of the keys
 * is guaranteed by using `RequiredKeys`.
 */
export declare type Schema<T> = () => yup.ObjectSchema<(T & {
    [key: string]: unknown;
}) | undefined> & {
    fields: RequiredKeys<Required<T>> | undefined;
};
/**
 * Types the validate function.
 */
export declare type Validate<T> = (obj: T) => Promise<T>;
export declare const MetadataSymbol: unique symbol;
export interface Metadata {
    [MetadataSymbol]: {
        model: string;
        namespace: string;
    };
}
/**
 * Types a model: exposes its schema
 * and the validate function
 */
export interface Model<T> {
    namespace: Namespaces;
    model: string;
    schema: Schema<T>;
    /**
     * Async validation, matching yup's `.validate`.
     * Injects the MetadataSymbol with model Metadata.
     */
    validate: (obj: unknown, options?: yup.ValidateOptions) => Promise<T & Metadata>;
    /**
     * Sync validation, matching yup's `.validateSync`.
     * Use it when you are 100% sure the model doesn't perform async validation.
     * Injects the MetadataSymbol with model Metadata.
     */
    validateSync: (obj: unknown, options?: yup.ValidateOptions) => T & Metadata;
    /**
     * Async validation, matching yup's `.isValid`.
     */
    isValid: (obj: unknown, options?: yup.ValidateOptions) => Promise<boolean>;
    /**
     * Checks whether the unknown object is an instance of T
     * by looking at the contents of MetadataSymbol.
     */
    isInstance: (obj: unknown) => obj is T;
}
/**
 * Extracts the Prop from the Model.
 * Helpful to type props when only the Model is given
 * i.e. Union Types
 */
export declare type ExtractProp<M> = M extends Model<infer X> ? X : never;
/**
 * Maps a union of models
 * to a union of props.
 *
 * @example
 * type ModelUnion = Model<X> | Model<Y> | Model<Z>
 * type Distribute<ModelUnion> = X | Y | Z
 */
export declare type MapModelsToProps<U> = U extends unknown ? ExtractProp<U> : never;
/**
 * Defines a model, returning a Model object
 * based on the provided Schema
 *
 * @param namespace
 * @param model
 * @param schema
 */
export declare const defineModel: <T>(namespace: Namespaces, model: string, schema: Schema<T>) => Model<T>;
/**
 * UUID Field.
 *
 * Defined here so that `uuid`
 * doesn't need to be imported
 * on other files.
 */
export declare const UUID: yup.StringSchema<string | undefined, object>;
/**
 * FirstName field.
 *
 * TODO: Implement FirstName validation
 */
export declare const FirstName: yup.StringSchema<string | undefined, object>;
/**
 * LastName field.
 *
 * TODO: Implement LastName validation
 */
export declare const LastName: yup.StringSchema<string | undefined, object>;
/**
 * Email field.
 *
 * TODO: Extend Email validation
 */
export declare const Email: yup.StringSchema<string | undefined, object>;
/**
 * Mobile field.
 *
 * TODO: Extend Mobile validation
 * (see `validateMobile`)
 */
export declare const Mobile: yup.StringSchema<string | undefined, object>;
/**
 * A line of a postal address.
 *
 * This regex comes from Marketing Preferences service, modified to fix some
 * bugs. Gift Aid doesn't seem to have any back-end address validation.
 *
 * todo: check whether we want to use this validation for other services, or
 * not have any validation at all. Is there a risk that a valid address could
 * be populated by the postcode lookup but then rejected by the backend?
 */
export declare const AddressLine: yup.StringSchema<string | undefined, object>;
/**
 * Unix Timestamp
 *
 * Represents a Unix Timestamp in seconds
 * and transforms it into a JavaScript Date
 */
export declare const UnixTimestamp: yup.DateSchema<Date | undefined, object>;
/**
 * Timestamp
 *
 * Represents an ISO timestamp
 * and keeps it as a string.
 *
 * Useful for validating strings
 * that should be valid timestamps
 * without casting them to Date objects.
 */
export declare const Timestamp: yup.StringSchema<string | undefined, object>;
/**
 * Timestamp or Now
 *
 * Extends Timestamp by adding
 * a default value, the current date time
 * in ISO format.
 */
export declare const TimestampOrNow: yup.StringSchema<string | undefined, object>;
/**
 * Non-empty string
 *
 * String values must be non-empty. Whitespace counts as empty.
 * `null` and `undefined` pass, as modifiers will handle these.
 */
export declare const NonEmptyString: yup.StringSchema<string | undefined, object>;
/**
 * JsonString
 *
 * Enforces that a string contains
 * a valid JSON document that will
 * successfully JSON.parse'd without
 * losing information.
 */
export declare const JsonString: yup.StringSchema<string | undefined, object>;
/**
 * StringBoolean
 *
 * Behaves quite like `boolean` but with a few casts:
 * - 'false' -> false
 * - 'null' -> false
 * - 'NaN' -> false
 * - 'undefined' -> false
 * - '0' -> false
 *
 * In some circumstances we might get a stringified value,
 * for example the results of AWS Athena queries that are
 * ignoring the `.csv.metadata` file and using only the `.csv` file.
 */
export declare const StringBoolean: yup.BooleanSchema<boolean | undefined, object>;
/**
 * Defines the shape of SupporterInfo.
 * This is the shape we should try to re-use
 * when passing supporter info across services
 * or from the frontend.
 */
export interface SupporterInfoProps {
    firstName: string;
    lastName: string;
    email: string;
    mobile: string;
    address1: string;
    postcode: string;
    town: string;
    country: string;
}
/**
 * Performs an email or mobile test,
 * checking that at least one of them
 * has been defined.
 *
 * Doesn't perform email validation
 * nor mobile validation, leaving the task
 * to the individual fields in the schema.
 */
export declare const EmailOrMobileTest: {
    name: string;
    message: string;
    test: (values: unknown) => boolean;
};
/**
 * Validates a SupporterInfo field
 */
export declare const SupporterInfo: yup.ObjectSchema<SupporterInfoProps | undefined, object>;
/**
 * Supporter UUID
 *
 * Represents a Supporter UUID
 * which is a required UUID by default
 * but can accept null/undefined if
 * `partial` is passed
 * to the context.
 */
export declare const SupporterUUID: yup.StringSchema<string | undefined, object>;
/**
 * Currencies used at CR.
 * These are the only currencies
 * accepted by `serverless-payments`
 */
export declare enum Currencies {
    AUD = "AUD",
    EUR = "EUR",
    GBP = "GBP",
    USD = "USD"
}
/**
 * Represents the currently
 * active campaign
 *
 * On change, we will need to update
 * this library to the latest version
 * on the following repositories:
 * - `serverless-payments`
 * - `serverless-prize-platform`
 */
export declare const CURRENT_CAMPAIGN = Campaigns.YRW;
/**
 * Values for an ERP `Checkbox` field.
 */
export declare enum NumericBool {
    NO = 0,
    YES = 1
}
/**
 * List of values in `NumericBool`.
 */
export declare const NumericBoolValues: NumericBool[];
/**
 * Schema for an ERP `Checkbox` field.
 */
export declare const NumericBoolField: yup.NumberSchema<NumericBool | undefined, object>;
/**
 * Represents an ERP `Currency` field.
 *
 * The value is a float, and the unit is to be specified in a separate `Link`
 * field of type `ErpCurrencyNames`.
 */
export declare type ErpCurrency = number;
/**
 * Schema for a `Currency` field.
 */
export declare const ErpCurrencyField: yup.NumberSchema<number, object>;
/**
 * Values from ERP's `Currency` list.
 */
export declare const ErpCurrencies: {
    readonly GBP: Currencies.GBP;
};
//# sourceMappingURL=validation.d.ts.map